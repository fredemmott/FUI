# Copyright 2024 Fred Emmott <fred@fredemmott.com>
# SPDX-License-Identifier: MIT
param($InputFile, $OutputFile, [switch]$Macros, [switch]$Enums, [switch]$Themes)

$XMLNS = @{
  p = "http://schemas.microsoft.com/winfx/2006/xaml/presentation";
  x = "http://schemas.microsoft.com/winfx/2006/xaml";
}
$ThemesXML = Select-Xml `
  -Path $InputFile `
  -Namespace $XMLNS `
  -XPath "/p:ResourceDictionary/p:ResourceDictionary.ThemeDictionaries/p:ResourceDictionary"

function Get-Key($Color)
{
  return $Color.GetAttribute("Key", $XMLNS.x)
}

function Get-Color($Node)
{
  $Key = Get-Key($Node)
  $value = $Node.InnerText -replace '#'
  if ($value.Length -eq 6)
  {
    # RGB -> ARGB
    $value = "ff${value}"
  }
  $value = "0x${value}"

  return @{
    Key = $Key;
    Value = $value;
  }
}

function Get-SolidColorBrush($Colors, $Brush)
{
  $Key = (Get-Key $Brush)
  $Lookup = $Brush.GetAttribute('Color')
  switch -regex ($Lookup)
  {
    'Transparent' {
      $Value = 'SK_ColorTRANSPARENT'
    }
    '#FF00FF' {
      # Other hex values are possible, but not actually used. This seems to be a test color
      $Value = 'SK_ColorMAGENTA'
    }
    '{ThemeResource System(Accent)?Color.*' {
      $Value = "SystemColor::$( $Lookup -replace '.* (System.+)}', '$1' )"
    }
    '{StaticResource .*Color.*}' {
      $Name = $Lookup -replace '.* ([A-Z][^ ]+)}$', '$1'
      $Color = $Colors | Where-Object -Property Key -eq $Name
      $Value = $Color.Value
    }
    default {
      Write-Host "ERROR: Can't figure out how to parse ${Lookup} in SolidColorBrush"
    }
  }
  return @{
    Key = $Key;
    Value = "SolidColorBrush { ${Value} }";
  }
}

function Get-LinearGradientBrush($Colors, $Brush)
{
  $Key = (Get-Key $Brush)
  return @{
    Key = $Key;
    Value = "LinearGradientBrush {}";
  }
}

function Get-Theme($Theme)
{
  $Colors = $Theme.Color | Sort-Object -Property { Get-Key($_) } | ForEach-Object { Get-Color($_) }
  $SolidColorBrushes = $Theme.SolidColorBrush | ForEach-Object { Get-SolidColorBrush $Colors $_ }
  if ($Theme.LinearGradientBrush)
  {
    $LinearGradientBrushes = $Theme.LinearGradientBrush | ForEach-Object { Get-LinearGradientBrush $Colors $_ }
  }
  $Brushes = ($SolidColorBrushes + $LinearGradientBrushes) | Sort-Object -Property Key
  return @{
    Name = $Theme.Key;
    Colors = $Colors;
    Brushes = $Brushes;
  }
}

$ThemeData = $ThemesXML | ForEach-Object { Get-Theme $_.Node }
$ColorKeys = $ThemeData[0].Colors | ForEach-Object { $_.Key } | Sort-Object | Get-Unique
$BrushKeys = $ThemeData[0].Brushes | ForEach-Object { $_.Key } | Sort-Object | Get-Unique

$CppNs = "FredEmmott::GUI::gui_detail::WinUI3Themes"

function Get-Enums-Cpp()
{
  return @"
namespace ${CppNs} {

enum class Colors {$(
  $ColorKeys.foreach({ "`n  $( $PSItem )," }) )
};

}
"@
}

function Get-Macros-Cpp()
{
  return @"
#define FUI_WINUI_THEME_COLORS(X) $(
  $ColorKeys.foreach({ "\`n  X($PSItem)" }) )
"@
}

function Get-Theme-Cpp($Theme)
{
  return @"
constexpr Theme $( $Theme.Name )Theme {$(
  $Theme.Colors.foreach({
    "`n  .m$( $PSItem.Key ) = $( $PSItem.Value ),"
  })
  $Theme.Brushes.foreach({
    "`n  .m$( $PSItem.Key ) = $( $PSItem.Value ),"
  })
  )
};`n
"@
}

function Get-Themes-Cpp()
{
  return @"
namespace $CppNs {

struct Theme {$(
  $ColorKeys.foreach({ "`n  SkColor m$PSItem;" })
  $BrushKeys.foreach({ "`n  Brush m$PSItem;" })
  )
};

$( ($ThemeData | ForEach-Object { Get-Theme-Cpp $_ }) -join "`n" )
}
"@
}

$Content = @"
// $( '@' )generated by: $( $( Get-Item $PSCommandPath ).Name ) $( $( Get-Item ${InputFile} ).Name )
#pragma once

$( if ($Themes)
{
  Write-Output @"
#include <skia/Core/SkColor.h>
#include <FredEmmott/GUI/Brush.hpp>
#include <FredEmmott/GUI/SystemColor.hpp>
"@
} )

$( if ($Macros)
{
  Get-Macros-Cpp
} )

$( if ($Enums)
{
  Get-Enums-Cpp
} )

$( if ($Themes)
{
  Get-Themes-Cpp
} )
"@

Write-Host "Writing $OutputFile"
($content -split "`r" -join "") `
  | Set-Content -Encoding utf8 "$OutputFile" -NoNewline
